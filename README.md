# JPA
## JPA에서 가장 중요한 2가지
- 객체와 관계형 데이터 베이스 매핑하기
- 영속성 컨텍스트

## 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 논리적인 개념
- em.persist(entity) <- 실제 DB에 저장하는게 아니라 영속성 컨텍스트에 저장하는 것임.
실제 DB에 날아가는건  commit 할 때임

## 플러시
- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- "쓰기지연" Sql 저장소의 쿼리를 데이터 베이스에 전송

## 준영속
- 영속성 컨텍스트에서 분리한 상태   
- ex> em.detach(member)
- em.detach(entity)  : 특정 엔티티만 준영속 상태로 전환
- em.clear() : 영속성 컨텍스트를 완전히 초기화
- em.close() : 영속성 컨텍스트를 종료

## 데이터베이스 스키마 자동 생성
- 애플리케이션 실행 시점에 테이블을 생성 (운영에서 사용X, 개발에서만 써야함)

## 필드와 컬럼 매핑
- @Column : 컬럼 매핑
- @Temporal : 날짜 타입 매핑
- @Enumerated : enum 타입 매핑
- @Lob : BLOB, CLOB 매핑
- @Transient : 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)

## 기본키 매핑
- 직접 할당 : @Id만 사용
- 자동 생성 : @GeneratedValue

순수 JPA를 쓸때에는 orderDate -> orderDate로 SQL로 그대로 가는데

스프링 부트를 쓰게 되면 orderDate -> order_date 로 변경되게끔 하는게 기본으로 된다.

## 연관관계가 필요한 이유
- 객체지향 설계의 목표는 자율적인 객체들의 `협력 공동체`를 만드는 것이다.
- 기존 테이블에 맞춘 설계 방식은 외래키를 객체에 변수로 만들어 넣게 되는데,
  이렇게 되면 실제 객체간에 필요한 값을 꺼낼 때에 이 외래키를 통해 '다시한번' 
  DB를 조회해서 값을 가져와야 하는 `객체지향적이지 않은` 방식으로 값을 
  가져올 수밖에 없다.
- 객체지향적으로 값을 가져오려면 양방향 연관관계를 가지는 객체 모델링을 통해
  객체간 참조를 할 수 있도록 해야 한다. (외래키 X)
  
## 연관관계 매핑시 고려사항 3가지
### 다중성

>#### 다대일[N:1] (앞에 나오는 '다' 가 연관관계의 주인)
>- @ManyToOne
>- Member -> Team
>- 가장 많이 사용하는 연관관계
>- 다대일의 반대는 일대다

>#### 일대다[1:N] (앞에 나오는 '일' 이 연관관계의 주인)
>- @OneToMany
>- 영한 선생님은 이 모델은 실무에서는 거의 쓰지 않는다고 함(스펙에 있기 때문에 설명만 하신다고..)
>- 테이블 일대다 관계는 '다' 쪽에 항상 외래키가 있음
>- 객체와 테이블의 이러한 차이 때문에 테이블의 외래키를 관리하게 되는 특이점 발생
>- 단점 : 1. 엔티티가 관리하는 외래키가 다른 테이블에 있음 2. 연관관계 관리를 위해 추가로 update문 실행
>- 그냥 `다대일` 쓰자

>#### 일대일[1:1]
>- @OneToOne
>- 단방향일 때, 외래키를 가진 객체 쪽에 연관된 객체 참조를 넣어주어야 함. 반대의 경우는 안됨.
>- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

>#### 다대다[N:M]
>- @ManyToMany
>- 관계형 데이터 베이스는 정규화된 테이블 2개로 다대다 관계 표현할 수 없음(연결테이블 필요)
>- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능
>- 실무에서 쓰면 안되는 것

### 단방향/양방향
- 테이블은 외래키 하나로 양쪽 조인 가능
- 객체는 한쪽 참조면 단방향, 양쪽 참조면 양방향(단방향 두개라고 보면 됨)
- 기본은 단방향으로 만드는 것이 좋고, 객체 참조를 통해 조회가 `필요`할 경우 양방향을 나중에 추가하면 됨

### 연관관계의 주인
- 테이블은 외래키 하나로 두 테이블이 연관관계를 맺음
- 객체 양방향 관계는 참조가 2군데
- 객체는 테이블의 외래키를 관리할 곳을 지정해야 하는데, 그게 연관관계의 주인이다.
